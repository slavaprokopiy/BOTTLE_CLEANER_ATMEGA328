/*
 * CFile1.c
 *
 * Created: 19.11.2015 8:27:36
 *  Author: prokopiy
 */ 
// Тактирование таймера
// Для формирования задержек в диапазоне от 5 секунд до 600 секунд при тактирующей частоте МК равной 16 МГц, 
// необходимо отсчитывать от [5*16e6 = 80e6] до [600*16e6 = 96*10e8] импульсов.

// Для 8-разрядного счетчика максимальное количество подсчитанных импульсов - 256. Таким образом, 
// необходимо уменьшить тактирующую частоту таймера в [96e8 / 256 = 37500000] раза. 

// Максимальный коэффициент деления предделителя тактовой частоты для таймера составляет 1024.
// Т.е. при использовании этого коэффициента необходимо будет посчитать переполнения таймера [37500000/1024 = 36621] раз (для 600 секунд).
// Тактирующая частота системы = 16 МГц. За одно переполнение таймера проходит [1/16e6]*256*1024 = 0.016384 секунд.

// Значит для интервала в 5 секунд необходимо посчитать [5/0.016384 = 305] переполнений таймера.
// Т.к. минимальная пауза, формируемая системой равна именно 5 секундам, будем использовать модуль таймера для отсчета 5 секунд.

// 10 sec			= 610
// 20 sec			= 1220
// 30 sec			= 1830
// 1 min _ 60 sec	= 3660
// 2 min _ 120 sec	= 7320
// 3 min _ 180 sec	= 10980
// 5 min _ 300 sec	= 18300
// 10 min_ 600 sec	= 36600

#include <asf.h>
#include <vars.h>
#include "adc.h"
#include <string.h>
#include "compiler.h"


extern uint8_t	STATUS_FLAG;
extern uint8_t	FLAG;
volatile uint32_t Timer_Delays;
uint16_t Timer_Int_Counter;
volatile uint8_t CurrentTimer;

//Настройка таймера =========
void timer_init(void){
//Разрешение прерывания по переполнению
	TIMSK0 |= 1<<TOIE0;

//Нормальный режим работы
	TCCR0A	&= ~(1<<WGM01 | 1<<WGM00);
	TCCR0B	&= ~(1<<WGM02);
}

void timer_start(uint8_t* Timer_Iterations){
	Timer_Int_Counter = 0;				//Сброс счетчика количества прерываний таймера
	Timer_Delays = Timer_Iterations;	//Установка количества 10-секундных отсчетов
	TCNT0 = 0;
	cli();
	//Запуск с тактированием от системной частоты с предделителем 1024
	TCCR0B |= 1<<CS02 | 1<<CS00;
	sei();
}

void timer_stop(void){
	cli();
	// Остановка таймера
	TCCR0B &= ~(1<<CS02 | 1<<CS00);
	TCNT0 = 0;
	sei();
}

//Прерывание таймера ========
ISR(TIMER0_OVF_vect){
	//Инкрементируем счетчик прерываний
	Timer_Int_Counter += 1;
	if(Timer_Int_Counter == 305) // Если прошла выдержка в 5 секунд
	{
		Timer_Int_Counter = 0;
		Timer_Delays -= 1;
		if(Timer_Delays == 0){ // Если это была последняя выдержка
			FLAG = FINISH;
			// Останавливаем таймер
			timer_stop();
		}
	}
}
